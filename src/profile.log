FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:149
Called 12 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
   12              0.000021   if s:is_vim
                                return a:client['channel']
   12              0.000008   endif
   12              0.000024   return a:client['chan_id']

FUNCTION  <SNR>35_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:189
Called 12 times
Total time:   0.001292
 Self time:   0.001203

count  total (s)   self (s)
   12   0.000338   0.000248   let channel = coc#client#get_channel(self)
   12              0.000027   if empty(channel)
                                return ''
   12              0.000006   endif
   12              0.000011   try
   12              0.000011     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
   12              0.000010     else
   12              0.000467       call call('rpcnotify', [channel, a:method] + a:args)
   12              0.000011     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
   12              0.000012   endtry

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 5 times
Total time:   0.018811
 Self time:   0.000635

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    5   0.002384   0.000104   if gitgutter#utility#is_active(a:bufnr)
                            
    5              0.000022     if has('patch-7.4.1559')
    5              0.000041       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    5              0.000003     endif
    5   0.016280   0.000383     let how = s:setup_path(a:bufnr, l:Callback)
    5              0.000027     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    5              0.000004       return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
                              endif

FUNCTION  <SNR>62_CursorHoldUpdate()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:399
Called 3 times
Total time:   0.000288
 Self time:   0.000083

count  total (s)   self (s)
    3              0.000015   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
    3              0.000002   endif
                            
    3   0.000257   0.000052   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
    3              0.000002     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  <SNR>64_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 5 times
Total time:   0.000960
 Self time:   0.000200

count  total (s)   self (s)
    5   0.000956   0.000195   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:139
Called 5 times
Total time:   0.015480
 Self time:   0.000823

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    5   0.000162   0.000068   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    5   0.002277   0.000194   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    5   0.000082   0.000071   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    5              0.000025     let handler = copy(s:set_path_handler)
    5              0.000013     let handler.continuation = a:continuation
    5   0.012851   0.000381     call gitgutter#async#execute(cmd, a:bufnr, handler)
    5              0.000018     return 'async'
                              endif
                            
                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  coc#float#check_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:809
Called 3 times
Total time:   0.000500
 Self time:   0.000201

count  total (s)   self (s)
    3              0.000010   let invalids = []
    3   0.000376   0.000078   let ids = coc#float#get_float_win_list(1)
    3              0.000006   for id in ids
                                let target = getwinvar(id, 'target_winid', 0)
                                if (target && index(ids, target) == -1) || getwinvar(id, 'kind', '') == 'pum'
                                  call add(invalids, id)
                                endif
    3              0.000006   endfor
    3              0.000006   if !s:popup_list_api
    3              0.000031     let s:popup_list = filter(ids, "index(invalids, v:val) == -1")
    3              0.000003   endif
    3              0.000007   for id in invalids
                                call coc#float#close(id)
    3              0.000004   endfor

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:36
Called 5 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    5              0.000083   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  coc#float#get_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1205
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000013   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
    2              0.000003   endfor
    2              0.000002   return 0

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 5 times
Total time:   0.012470
 Self time:   0.012247

count  total (s)   self (s)
    5   0.000265   0.000069   call gitgutter#debug#log('[async] '.a:cmd)
                            
    5              0.000026   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    5   0.000069   0.000042   let command = s:build_command(a:cmd)
                            
    5              0.000013   if has('nvim')
    5              0.011818     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    5              0.000004   endif

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 5 times
Total time:   0.000245
 Self time:   0.000085

count  total (s)   self (s)
    5   0.000243   0.000082   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>64_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 5 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    5              0.000045   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>64_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 10 times
Total time:   0.001454
 Self time:   0.000216

count  total (s)   self (s)
   10   0.001449   0.000211   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>32_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:245
Called 9 times
Total time:   0.001306
 Self time:   0.000149

count  total (s)   self (s)
    9              0.000026   if !g:coc_service_initialized
                                return
    9              0.000008   endif
    9   0.001239   0.000082   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  <SNR>213_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 5 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    5              0.000011   if has('unix')
    5              0.000012     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 5 times
Total time:   0.000195
 Self time:   0.000195

count  total (s)   self (s)
    5              0.000008   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    5              0.000003   endif

FUNCTION  186()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:37
Called 3 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    3              0.000004     return 'NERD_tree_'

FUNCTION  <SNR>32_AsyncRequest()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:112
Called 3 times
Total time:   0.000781
 Self time:   0.000167

count  total (s)   self (s)
    3              0.000044   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
    3              0.000016   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    3              0.000003   endif
    3   0.000654   0.000040   call coc#rpc#notify(a:name, a:args)
    3              0.000003   return ''

FUNCTION  <SNR>64_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 5 times
Total time:   0.000891
 Self time:   0.000123

count  total (s)   self (s)
    5   0.000888   0.000119   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 5 times
Total time:   0.001413
 Self time:   0.000138

count  total (s)   self (s)
    5   0.000675   0.000086   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    5   0.000734   0.000048   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  gitgutter#all()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 2 times
Total time:   0.007552
 Self time:   0.000432

count  total (s)   self (s)
    2              0.000006   let visible = tabpagebuflist()
                            
    8              0.000022   for bufnr in range(1, bufnr('$') + 1)
    6              0.000014     if buflisted(bufnr)
    2              0.000154       let file = expand('#'.bufnr.':p')
    2              0.000006       if !empty(file)
    2              0.000005         if index(visible, bufnr) != -1
    2   0.007229   0.000108           call gitgutter#process_buffer(bufnr, a:force)
                                    elseif a:force
                                      call s:reset_tick(bufnr)
    2              0.000001         endif
    2              0.000001       endif
    6              0.000004     endif
    8              0.000017   endfor

FUNCTION  coc#float#get_float_win_list()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:606
Called 3 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
    3              0.000007   let res = []
    3              0.000015   let all = get(a:, 1, 0)
    3              0.000005   if s:is_vim
                                if s:popup_list_api
                                  return filter(popup_list(), 'popup_getpos(v:val)["visible"]'.(all ? '' : '&& getwinvar(v:val, "float", 0)'))
                                endif
                                return filter(s:popup_list, 's:popup_visible(v:val)')
    3              0.000028   elseif has('nvim') && exists('*nvim_win_get_config')
    3              0.000007     let res = []
    6              0.000031     for i in range(1, winnr('$'))
    3              0.000013       let id = win_getid(i)
    3              0.000040       let config = nvim_win_get_config(id)
    3              0.000018       if empty(config) || empty(config['relative'])
    3              0.000005         continue
                                  endif
                                  " ignore border & button window & others
                                  if !all && !getwinvar(id, 'float', 0)
                                    continue
                                  endif
                                  call add(res, id)
    3              0.000011     endfor
    3              0.000005     return res
                              endif
                              return []

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:32
Called 12 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
   12              0.000075   if empty(s:client) || s:client['running'] == 0
                                return 0
   12              0.000008   endif
   12              0.000011   return 1

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 15 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
   15              0.000263   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   15              0.000023     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 5 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    5              0.000007   return s:available

FUNCTION  <SNR>213_on_exit_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 5 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    5              0.000017   if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    5              0.000004   endif

FUNCTION  CocActionAsync()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:82
Called 3 times
Total time:   0.000862
 Self time:   0.000081

count  total (s)   self (s)
    3   0.000853   0.000072   return s:AsyncRequest(a:name, a:000)

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 10 times
Total time:   0.000217
 Self time:   0.000217

count  total (s)   self (s)
   10              0.000031   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   10              0.000042   let ggvars = getbufvar(buffer, 'gitgutter')
   10              0.000030   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
   10              0.000008   endif
   10              0.000027   let ggvars[a:varname] = a:val

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 5 times
Total time:   0.000161
 Self time:   0.000090

count  total (s)   self (s)
    5   0.000142   0.000072   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
    5              0.000015   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>97_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 5 times
Total time:   0.015897
 Self time:   0.000172

count  total (s)   self (s)
    5   0.000295   0.000050   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
    5   0.015589   0.000108   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 5 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    5              0.000041   return has('win64') || has('win32') || has('win16')

FUNCTION  <SNR>64_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 25 times
Total time:   0.002801
 Self time:   0.002801

count  total (s)   self (s)
   25              0.002092   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   25              0.000551   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   25              0.000088   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  223()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 3 times
Total time:   0.000166
 Self time:   0.000160

count  total (s)   self (s)
    3              0.000009     if exists('t:NERDTreeBufName')
                                    return bufwinnr(t:NERDTreeBufName)
    3              0.000002     endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
    6              0.000020     for w in range(1,winnr('$'))
    3   0.000078   0.000072         if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
    3              0.000002         endif
    6              0.000008     endfor
                            
    3              0.000003     return -1

FUNCTION  224()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 3 times
Total time:   0.000205
 Self time:   0.000039

count  total (s)   self (s)
    3   0.000203   0.000037     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  <SNR>86_Remove_Matches()
    Defined: /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/plugin/matchparen.vim:197
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000007   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
    2              0.000001   endif

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 5 times
Total time:   0.002279
 Self time:   0.000282

count  total (s)   self (s)
    5   0.002275   0.000277   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>64_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 5 times
Total time:   0.000545
 Self time:   0.000053

count  total (s)   self (s)
    5   0.000543   0.000050   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:781
Called 2 times
Total time:   0.000073
 Self time:   0.000043

count  total (s)   self (s)
    2   0.000061   0.000030   let id = coc#float#get_related(a:winid, 'scrollbar')
    2              0.000005   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
    2              0.000001   endif

FUNCTION  287()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:131
Called 5 times
Total time:   0.000224
 Self time:   0.000101

count  total (s)   self (s)
    5   0.000221   0.000098   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:96
Called 12 times
Total time:   0.001771
 Self time:   0.000352

count  total (s)   self (s)
   12   0.000235   0.000109   if !coc#rpc#ready()
                                return ''
   12              0.000006   endif
   12   0.001489   0.000196   call s:client['notify'](a:method, a:args)
   12              0.000014   return ''

FUNCTION  <SNR>213_on_stderr_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 10 times
Total time:   0.000410
 Self time:   0.000186

count  total (s)   self (s)
   10              0.000059   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
    5   0.000290   0.000066     call self.handler.err(self.buffer)
   10              0.000009   endif

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 10 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
   10              0.000052   let ggvars = getbufvar(a:buffer, 'gitgutter')
   10              0.000065   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
    5              0.000011     return ggvars[a:varname]
    5              0.000004   endif
    5              0.000004   if a:0
    5              0.000005     return a:1
                              endif

FUNCTION  <SNR>86_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/0.5.0/share/nvim/runtime/plugin/matchparen.vim:40
Called 2 times
Total time:   0.001496
 Self time:   0.001480

count  total (s)   self (s)
                              " Remove any previous match.
    2   0.000029   0.000013   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    2              0.000010   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    2              0.000001   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    2              0.000006   let c_lnum = line('.')
    2              0.000004   let c_col = col('.')
    2              0.000002   let before = 0
                            
    2              0.000005   let text = getline(c_lnum)
    2              0.000071   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    2              0.000004   if empty(matches)
                                let [c_before, c] = ['', '']
    2              0.000001   else
    2              0.000008     let [c_before, c] = matches[1:2]
    2              0.000001   endif
    2              0.000036   let plist = split(&matchpairs, '.\zs[:,]')
    2              0.000006   let i = index(plist, c)
    2              0.000002   if i < 0
                                " not found, in Insert mode try character before the cursor
    1              0.000004     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    1              0.000001     endif
    1              0.000001     if i < 0
                                  " not found, nothing to do
    1              0.000001       return
                                endif
    1              0.000000   endif
                            
                              " Figure out the arguments for searchpairpos().
    1              0.000001   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    1              0.000000   else
    1              0.000001     let s_flags = 'nbW'
    1              0.000001     let c2 = c
    1              0.000002     let c = plist[i - 1]
    1              0.000000   endif
    1              0.000001   if c == '['
                                let c = '\['
                                let c2 = '\]'
    1              0.000000   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    1              0.000001   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    1              0.000000   endif
                            
    1              0.000005   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    1              0.000000   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
    1              0.000004     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    1              0.000001     try
    1              0.000631       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    1              0.000001     endtry
    1              0.000000   endif
                            
                              " Limit the search to lines visible in the window.
    1              0.000003   let stoplinebottom = line('w$')
    1              0.000002   let stoplinetop = line('w0')
    1              0.000001   if i % 2 == 0
                                let stopline = stoplinebottom
    1              0.000001   else
    1              0.000005     let stopline = stoplinetop
    1              0.000000   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    1              0.000003   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    1              0.000000   else
    1              0.000004     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    1              0.000000   endif
    1              0.000001   try
    1              0.000416     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    1              0.000001   endtry
                            
    1              0.000001   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    1              0.000000   endif
                            
                              " If a match is found setup match highlighting.
    1              0.000002   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    1              0.000003     if exists('*matchaddpos')
    1              0.000038       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    1              0.000000     endif
    1              0.000002     let w:paren_hl_on = 1
    1              0.000001   endif

FUNCTION  <SNR>64_filename()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:219
Called 5 times
Total time:   0.000604
 Self time:   0.000051

count  total (s)   self (s)
    5   0.000602   0.000048   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>213_on_stdout_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 5 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    5              0.000027   if empty(self.stdoutbuffer)
    5              0.000014     let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    5              0.000003   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    5   0.018811   0.000635  gitgutter#process_buffer()
    5   0.015897   0.000172  <SNR>97_setup_path()
    5   0.015480   0.000823  gitgutter#utility#set_repo_path()
    5   0.012470   0.012247  gitgutter#async#execute()
    2   0.007552   0.000432  gitgutter#all()
   25   0.002801             <SNR>64_abs_path()
    5   0.002279   0.000282  gitgutter#utility#is_active()
   12   0.001771   0.000352  coc#rpc#notify()
    2   0.001496   0.001480  <SNR>86_Highlight_Matching_Pair()
   10   0.001454   0.000216  <SNR>64_dir()
    5   0.001413   0.000138  gitgutter#utility#cd_cmd()
    9   0.001306   0.000149  <SNR>32_Autocmd()
   12   0.001292   0.001203  <SNR>35_notify()
    5   0.000960   0.000200  <SNR>64_exists_file()
    5   0.000891   0.000123  <SNR>64_not_git_dir()
    3   0.000862   0.000081  CocActionAsync()
    3   0.000781   0.000167  <SNR>32_AsyncRequest()
    5   0.000604   0.000051  <SNR>64_filename()
    5   0.000545   0.000053  <SNR>64_unc_path()
    3   0.000500   0.000201  coc#float#check_related()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    5   0.012470   0.012247  gitgutter#async#execute()
   25              0.002801  <SNR>64_abs_path()
    2   0.001496   0.001480  <SNR>86_Highlight_Matching_Pair()
   12   0.001292   0.001203  <SNR>35_notify()
    5   0.015480   0.000823  gitgutter#utility#set_repo_path()
    5   0.018811   0.000635  gitgutter#process_buffer()
    2   0.007552   0.000432  gitgutter#all()
   12   0.001771   0.000352  coc#rpc#notify()
   15              0.000309  gitgutter#utility#shellescape()
    3              0.000298  coc#float#get_float_win_list()
    5   0.002279   0.000282  gitgutter#utility#is_active()
   10              0.000217  gitgutter#utility#setbufvar()
   10   0.001454   0.000216  <SNR>64_dir()
    3   0.000500   0.000201  coc#float#check_related()
    5   0.000960   0.000200  <SNR>64_exists_file()
    5              0.000195  gitgutter#debug#log()
   10   0.000410   0.000186  <SNR>213_on_stderr_nvim()
    5   0.015897   0.000172  <SNR>97_setup_path()
   10              0.000168  gitgutter#utility#getbufvar()
    3   0.000781   0.000167  <SNR>32_AsyncRequest()

